#! /usr/bin/env python

__prog__ = "pycbc_plot_volumes"
__author__ = "Collin Capano <collin.capano@ligo.org>"
__description__ = \
"""Creates plots of sensitive volumes as well as summary pages. Will also
gather plots from other progams and place them on the summary pages."""

import os, sys, shutil
from optparse import OptionParser
import numpy
from pycbc import distributions
from pycbc.plot import plot_utils
from pycbc.plot import efficiency
from pycbc.plot import plot_volumes


def print_command_line(args):
    """
    Prints the commands given to the program to run; this can be added to the
    bottom of an html page.
    """
    return "Created with:<br />%s" %(' '.join(args))

parser = OptionParser()
parser.add_option('-c', '--cache-file', help='Required. Cache file containing result databases.')
parser.add_option('-l', '--layer-config-file', help='Required. A config file containing the layer parameters to use.') 
parser.add_option('-T', '--threshold', type='float', help='Required. The value of the ranking stat to use as the threshold when computing efficiencies.')
parser.add_option('-R', '--ranking-stat', metavar='stat[:stat_label]', default=r'new_snr:$\hat{\rho}$', help='The ranking stat to use for computing efficiency. Can also specify a stat label for plotting (latex math should be enclosed in $ signs). Default is new_snr:$\hat{\rho}$.')
parser.add_option('-B', '--rank-by', default='max', help='Options are "max" or "min". If max (min) an injection will be considered found if its ranking stat is >= (<) the threshold. Default is max.')
parser.add_option('-r', '--stat-range', metavar='MIN_STAT,MAX_STAT[:log]', default='6,12', help='Stat range to use when creating volume vs. stat plots. Must specify both a minimum and a maximum. If would like the stat distribution to be log10, add ":log" after the max stat. Default is 6,12.')
parser.add_option('-N', '--min-ninj', type='int', default=2, help='Minimum number of injections that must exist in a block in in order to calculate volume. If a block has less then this, it will be skipped. Default is 2.')
parser.add_option('', '--print-relative-error', action='store_true', default=False, help='Turn on to print relative errors instead of absolute errors.')
parser.add_option('', '--use-distance-bins', action='store_true', default=False, help="If turned on, will use distance bins to compute sensitive volumes, rather than the standard Monte Carlo method of using the average of the integrand. Generally, this will yield larger variance, so turn this on with caution.")
parser.add_option('-A', '--astrophysical-prior', metavar='AST_DISTR.cfg', help='Use the astrophysical prior provided in the given config file. Default is to use whatever was used in the injection set.')
parser.add_option('-G', '--use-global-norm', action='store_true', default=False, help='Normalize volumes in each tile such that they add up to the total volume across all volumes. In this case, the volumes in each tile give the contribution of that tile to the whole. Otherwise, the volume in each tile is as if the universe only contained signals in that tile.')
parser.add_option('-p', '--additional-plots-cache', metavar='FILE1.cache[,FILE2.cache,...]', help='Load additional plots for each cube from the given cache file(s). To specify multiple cache files, comma separate each file name. All cache files must have used the same layer-configuration-file.')
parser.add_option('', '--skip-volume-vs-stat-plots', action='store_true', default=False, help="Don't create volume vs. stat plots.")
parser.add_option('-o', '--output-dir', help='Directory to save results to.')
parser.add_option('-u', '--user-tag', default='', help='Add a user tag to all output files.')
parser.add_option('', '--colormap', default='hot', help='What color map to use for fractional gain plots. Default is hot.')
parser.add_option('', '--minvol', type='float', default=None, help='Minimum volume to color. Default is to use whatever the minium volume found is.')
parser.add_option('', '--maxvol', type='float', default=None, help='Maximum volume to color. Default is to use whatever the maximum volume found is.')
parser.add_option('', '--fontsize', type='int', default=8, help='Fontsize to use in volume plots. Default is 8.')
parser.add_option('', '--logz', action='store_true', default=False, help='Make coloring log10.')
parser.add_option('', '--dpi', type='int', default=300, help='dpi to use for plots; default is 300')
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help = 'apply cut to injections; can specify multiple times')
parser.add_option('-M', '--mapper', default=None, help="Specify the location of a mapper.js JavaScript in order to highlight tiles on mouse over.")

opts, _ = parser.parse_args()

if opts.user_tag is not None:
    tag = '_%s' % opts.user_tag
else:
    tag = ''
if not opts.cache_file:
    raise ValueError('cache-file required')
if not opts.output_dir:
    raise ValueError('output-dir required')

if opts.astrophysical_prior is not None:
    astprior = distributions.load_distribution_from_config(
        opts.astrophysical_prior)
else:
    astprior = None

# set the distance bins option if desired
efficiency.PHyperCube.use_distance_bins = opts.use_distance_bins

stat_info = opts.ranking_stat.split(':')
if len(stat_info) == 1:
    ranking_stat = stat_info[0]
    stat_label = ranking_stat.replace('_', ' ')
elif len(stat_info) == 2:
    ranking_stat, stat_label = stat_info
else:
    raise ValueError("ranking-stat not formatted correctly; see help")

stat_info = opts.stat_range.split(',')
if len(stat_info) != 2:
    raise ValueError("stat-range nto formatted correctly; see help")
min_stat, max_stat = stat_info
if len(max_stat.split(':')) == 2:
    max_stat, stat_dist = max_stat.split(':')
    if stat_dist != 'log':
        raise ValueError('unrecognized stat distribution %s '%(stat_dist) +
            'given in stat-range; see help')
    stat_dist = True
else:
    stat_dist = False
min_stat = float(min_stat)
max_stat = float(max_stat)

# load the layers
layers = efficiency.create_layers_from_config(opts.layer_config_file,
    cube_type='single')

# create the directory structure: layer0 goes in the top level folder.
# Each sub-layer are placed in sub-folders. Every folder has an images
# directory where plots are stored.
imgdir = 'images'
scriptdir = 'scripts/'
this_folder = '/'
for ii,layer in enumerate(layers):
    try:
        os.mkdir('%s%s' %(opts.output_dir, this_folder))
    except OSError:
        pass
    # make the images folder
    try:
        os.mkdir('%s%s%s' %(opts.output_dir, this_folder, imgdir))
    except OSError:
        pass
    # make scripts foler if necessary
    if opts.mapper is not None:
        try:
            os.mkdir('%s%s%s' %(opts.output_dir, this_folder, scriptdir))
        except OSError:
            pass
        shutil.copy2(opts.mapper, '%s%s%s' %(
            opts.output_dir, this_folder, scriptdir)) 
        mapper = '%s/%s' %(scriptdir, os.path.basename(opts.mapper))
    else:
        mapper = None
    layer.root_dir = opts.output_dir
    layer.web_dir = this_folder
    layer.images_dir = imgdir
    # update this_folder for the next lower layer
    this_folder = '%slayer%i/'%(this_folder, ii+1) 

# if an astrophysical prior is desired, set it for all of the cubes
if astprior is not None:
    for pcube in efficiency.get_all_cubes_in_layers(layers[0]):
        pcube.set_astro_prior(astprior)

# if additional plots cache are specified, load them
if opts.additional_plots_cache is not None:
    print "creating symbolic links to additional plots..."
    plot_cache = {}
    # get this layer config file's checksum for comparison
    layers_checksum = efficiency.get_layers_checksum(layers[0])
    for cache in opts.additional_plots_cache.split(','):
        _, this_checksum, this_cache = efficiency.load_plot_cache(cache) 
        if this_checksum != layers_checksum:
            raise ValueError("the layer hierarchy in " +\
                "plot cache %s does not have the same checksum " %(cache) +\
                "as the layer hierarchy from the given layer-config-file")
        for tile_layer_id, filelist in this_cache.items():
            plot_cache.setdefault(tile_layer_id, [])
            plot_cache[tile_layer_id] += filelist
    this_layer = layers[0]
    while this_layer is not None:
        # if the bottom layer, also create links for the additional plots
        # to the children
        if this_layer.sub_layer is None:
            pcubes = this_layer.parents + this_layer.all_children
        else:
            pcubes = this_layer.parents
        for pcube in pcubes:
            try:
                add_plots = plot_cache[pcube.id_in_layer]
            except KeyError:
                continue
            for plot in add_plots:
                # create a symbolic link to the plot in the layer's image dir
                figname = '%s%s%s/%s' %(this_layer.root_dir,
                    this_layer.web_dir, this_layer.images_dir,
                    os.path.basename(plot))
                # ensure that we can create a symlink
                try:
                    os.remove(figname)
                except OSError:
                    pass
                os.symlink(plot, figname)
                # add the figname to the pcube's additional plots
                pcube.additional_plots.append(figname)
        this_layer = this_layer.sub_layer


print "getting results"
filenames = plot_utils.parse_results_cache(opts.cache_file)
results, id_map = plot_utils.get_injection_results(filenames,
    load_inj_distribution=True, verbose=True)

print "total number of injections: %i" %(len(results))
apply_cut = {}
for thiscut in opts.apply_cut:
    arg, vals = thiscut.split(':')
    apply_cut[arg] = map(float, vals.split(','))
if apply_cut:
    print "applying cuts"
    results = plot_utils.slice_results(results, apply_cut)
    print "total number of injections after cuts: %i" %(len(results))

# set the top level data and ranking parameters
print "binning data"
layers[0].set_cube_data(results)
layers[0].set_ranking_params(ranking_stat, opts.rank_by, stat_label)

# now go down through the other layers, set the rest of the data
next_layer = layers[0].sub_layer
while next_layer is not None:
    next_layer.set_cube_data_using_super()
    next_layer.set_ranking_params(ranking_stat, opts.rank_by, stat_label)
    next_layer = next_layer.sub_layer

# if desired, set the global normalization
if opts.use_global_norm:
    # if no astro prior is specified, this is just the total number of
    # injections
    if astprior is None:
        norm = float(len(results))
    # otherwise, the norm is the sum of the weights of all of the injections
    else:
        weights = numpy.array([distributions.convert_distribution(
            x, x.inj_mass_distr, astprior) for x in results
            if x.inj_weight is not None])
        norm = weights.sum() 
    # now set the global norm for all the phyper cubes
    for pcube in efficiency.get_all_cubes_in_layers(layers[0]):
        pcube.global_norm = norm
        # also set the total number of samples for computing variance
        pcube.total_nsamples = len(results)

# if min, max vol aren't specified, get the minimum/maximum volumes across
# all of the tiles
minvol = opts.minvol
maxvol = opts.maxvol
#if minvol is None or maxvol is None:
#    print "getting min, max volumes"
#    Vs = numpy.array([child.get_volume(opts.threshold)[0] \
#        for layer in layers \
#        for child in layer.all_children if child.nsamples >= opts.min_ninj
#        and child.get_volume(opts.threshold)[0] != 0.])
#    if minvol is None:
#        minvol = Vs.min()
#    if maxvol is None:
#        maxvol = Vs.max()
#minvol = None
#maxvol = None

# for keeping track of commands, we'll add the arguments used to create this
# at the bottom of the html pages
command_line = print_command_line(sys.argv)

# Plot
print "plotting"
html_tmplt = '%slevel_%i-%s_%i.html'
# we'll create the plots from the bottom layers up, so that we can provide
# links to each lower layer
this_layer = layers[-1]
while this_layer is not None:
    # for the bottom layer, we'll also create html and volume vs stat plots
    # for the children
    this_is_lowest_layer = this_layer.sub_layer is None
    if not opts.skip_volume_vs_stat_plots:
        plot_volumes.plot_volume_vs_stat_from_layer(this_layer, min_stat,
            max_stat, stat_label, include_children=this_is_lowest_layer,
            user_tag=opts.user_tag, min_ninj=opts.min_ninj, logx=stat_dist,
            logy=True, nbins=20, threshold=opts.threshold, dpi=opts.dpi,
            verbose=True)

    plot_volumes.plot_volumes_from_layer(this_layer, opts.threshold,
        user_tag=opts.user_tag, min_ninj=opts.min_ninj,
        tmplt_label='', inj_label='', colormap=opts.colormap,
        maxvol=maxvol, minvol=minvol, fontsize=opts.fontsize,
        print_relative_err=opts.print_relative_error,
        logz=opts.logz, dpi=opts.dpi, verbose=True)

    # if not the last layer, create the subvolumes plot
    if not this_is_lowest_layer:
        plot_volumes.plot_subvolumes_from_layer(this_layer, opts.threshold,
            user_tag=opts.user_tag, min_ninj=opts.min_ninj,
            tmplt_label='', inj_label='', colormap=opts.colormap,
            maxvol=maxvol, minvol=minvol,
            logz=opts.logz, dpi=opts.dpi, verbose=True)

    # write the html page
    # if this is the bottom layer, create pages for the children
    if this_is_lowest_layer:
        for ii,child in enumerate(this_layer.all_children):
            html_name = html_tmplt %(this_layer.web_dir, this_layer.level,
                'child', ii)
            child.create_html_page(this_layer.root_dir, html_name,
                mapper=None, threshold=opts.threshold,
                print_relative_error=opts.print_relative_error,
                comments=command_line)
    # the top layer page is the index page; otherwise we use the template
    for ii,parent in enumerate(this_layer.parents):
        if this_layer.level == 0:
            html_name = '/index.html'
        else:
            html_name = html_tmplt %(this_layer.web_dir, this_layer.level,
                'parent', ii)
        parent.create_html_page(this_layer.root_dir, html_name,
            mapper=mapper, threshold=opts.threshold,
            print_relative_error=opts.print_relative_error,
            comments=command_line)

    this_layer = this_layer.super_layer
