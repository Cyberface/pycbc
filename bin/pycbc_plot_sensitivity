#! /usr/bin/env python

__prog__ = 'pycbc_plot_sensitivity'
__author__ = 'Collin Capano <collin.capano@ligo.org>'
__description__ = 'Plots volume(*time) versus the given statistic.'
__usage__ = '%s [OPTIONAL_COMMANDS] CACHE_FILE1.cache:TYPE[:LABEL1:COLOR1:APPROXIMANT] CACHE_FILE2.cache:TYPE[:LABEL2:COLOR2:APPROXIMANT] ...' % __prog__ + """

The results in all of the databases listed in each cache file will be combined
and plotted together as a single volume. The z-order of the lines is
determined by the order that the cache files are provided. You must specify
what type of result files are stored in each cache file after the file name;
e.g., "CACHE_FILE1.cache:pycbc_sqlite". Optional arguments after the
cache-file name can be used to adjust what is plotted together and other plot
attributes. For example, if you want the results in CACHE_FILE1.cache to be
labelled 'foo' in the legend, type CACHE_FILE1.cache:TYPE:"foo". To specify a
color to use add a colon followed by the color after the label.  Any
matplotlib color is permitted. If no color is specified, the jet colormap will
be used. To specify a specific injection approximant, add the approximant name
after the color. If no approximant is specified, all approximants present in
the result files will be plotted. To skip an argument, just leave the argument
blank. For example, if you wanted to specify a color but not a label, you
would type "CACHE_FILE1.cache:TYPE::blue"."""

import os, sys
import sqlite3
from optparse import OptionParser
import math
import numpy
from pycbc import distributions
from pycbc import plot
from pycbc.plot import plot_utils
from pycbc.plot import efficiency
from pycbc.plot import plot_volumes

parser = OptionParser(description=__description__, usage=__usage__)
parser.add_option('-o', '--output', help='Required. File name of output plot.')
parser.add_option('-m', '--map-label', help='Required if any of the cache files contain pycbc_sqlite databases. The map label to use when getting found injections.')
parser.add_option('-r', '--ranking-stat', metavar='stat[:stat_label]', help=r'Required. The ranking stat to use for computing efficiency. Can also specify a stat label for plotting (latex math should be enclosed in $ signs).')
parser.add_option('-B', '--rank-by', help='Required. Options are "max" or "min". If max (min) an injection will be considered found if its ranking stat is >= (<) the threshold.')
parser.add_option('-R', '--stat-range', metavar='MIN_STAT,MAX_STAT', help='Stat range to use when creating volume vs. stat plots. Must specify both a minimum and a maximum.')
parser.add_option('-T', '--include-livetime', action='store_true', default=False, help='Plot VT instead of just V.')
parser.add_option('-A', '--astrophysical-prior', metavar='AST_DISTR.cfg', help='Use the astrophysical prior provided in the given config file. Default is to use whatever was used in the injection set.')
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help='Only include injections that have the given argument in the given range. If specified multiple times, only injections passing all specified cuts will be plotted.')
parser.add_option('-L', '--logx', action='store_true', default=False, help='Make the x-axis log.')
parser.add_option('-U', '--y-min', type='float', help='min y for plot')
parser.add_option('-V', '--y-max', type='float', help='max y for plot')
parser.add_option('-N', '--npoints', type='int', default=20, help='Number of points at which to calculate the sensitive volume. The points will be distributed between the min and max stat values. Default is 20.')
parser.add_option('-d', '--dpi', type='int', default=200, help='DPI to use for plots; default is 200. Not used if saving the plot as a pdf.')

opts, cache_files = parser.parse_args()

stat_info = opts.ranking_stat.split(':')
if len(stat_info) == 1:
    ranking_stat = stat_info[0]
    stat_label = ranking_stat.replace('_', ' ')
elif len(stat_info) == 2:
    ranking_stat, stat_label = stat_info
else:
    raise ValueError("ranking-stat not formatted correctly; see help")

if not (opts.rank_by == 'max' or opts.rank_by == 'min'):
    raise ValueError("rank-by must be either 'max' or 'min'")

stat_info = opts.stat_range.split(',')
if len(stat_info) != 2:
    raise ValueError("stat-range not formatted correctly; see help")
min_stat, max_stat = map(float, stat_info)

if opts.astrophysical_prior is not None:
    astprior = distributions.load_distribution_from_config(
        opts.astrophysical_prior)
else:
    astprior = None

apply_cut = {}
for thiscut in opts.apply_cut:
    arg, vals = thiscut.split(':')
    apply_cut[arg] = map(float, vals.split(','))

print "Cycling over cache files:"
pcubes = []
labels = []
colors = []
livetimes = []
for ii,cache_file_arg in enumerate(cache_files):
    print "%i / %i" %(ii+1, len(cache_files))
    # parse the cache file arguments
    cache_file_arg = cache_file_arg.split(':')
    if len(cache_file_arg) == 2:
        cache_file, results_type = cache_file_arg
        label = color = approx = None
    elif len(cache_file_arg) == 3:
        cache_file, results_type, label = cache_file_arg
        approx = color = None
    elif len(cache_file_arg) == 4:
        cache_file, results_type, label, color = cache_file_arg
        approx = None
        weight_function = 'uniform'
    elif len(cache_file_arg) == 5:
        cache_file, results_type, label, color = cache_file_arg
        approx = None
    elif len(cache_file_arg) == 6:
        cache_file, results_type, label, color, approx = cache_file_arg
    else:
        raise ValueError("cache file %s is not in correct format; " %(
            cache_file_arg) + "see help message")

    if results_type not in plot_utils.known_result_types:
        raise ValueError("unrecognized result file type %s; "  %(
            results_type) + "see --reference-cache-file help")
    if results_type == 'pycbc_sqlite' and opts.map_label is None:
        raise ValueError("results type is pycbc_sqlite, but no --map-label " +
            "specified")
    if results_type == 'overlaps' and opts.include_livetime:
        raise ValueError("cannot include-livetime for overlaps databases")

    if label == '':
        label = 'cache %i' % ii
    if approx == '':
        approx = None

    print "  getting results"
    filenames = plot_utils.parse_results_cache(cache_file)
    if results_type == "overlaps":
        results, _ = plot_utils.get_injection_results(filenames,
            load_inj_distribution=True, verbose=True)
        # exclude any zero SNRs
        print "excluding injections with SNR = 0."
        results = [x for x in results if x.snr != 0. or x.snr is None]
    else:
        results, _ = plot_utils.get_pycbc_sqlite_injection_results(filenames,
            opts.map_label)
    if apply_cut:
        print "  applying cuts"
        results = plot_utils.slice_results(results, apply_cut)

    # get the desired approximant
    if approx is not None:
        # if approximant specified only get that approximant
        results = [x for x in results if x.approximant == approx]
        if results == []:
            raise ValueError("approximant %s not found " %(approx) +\
                "in the databases in cache %s" %(cache_file))

    # create a PHyperCube to store the data
    pcube = efficiency.PHyperCube()
    pcube.set_ranking_params(ranking_stat, opts.rank_by, stat_label)
    pcube.set_data(results)
    pcube.set_astro_prior(astprior)

    pcubes.append(pcube)
    labels.append(label)
    colors.append(color)

    # if desired, get the livetime too
    if opts.include_livetime:
        # we only need the simulation livetimes
        livetime = plot_utils.get_livetime_from_pycbc_sqlite(filenames
            )['simulation']
        # Since all of the on_instruments are gathered, and since, by
        # by definition, the on_instrument times do not intersect, we will
        # just add them all up
        # Note: I'm ignoring the veto_def_name here; this can lead to errors
        # if there are multiple vetoe cats in a single database; in that
        # case, I'll just raise an error
        if len(set([veto_cat for (_,veto_cat) in livetime])) != 1:
            raise ValueError("file %s has multiple veto categorgies, but " +\
                "I can only handle one veto category in each file; sorry!")
        livetime = sum([dur for _,dur in livetime.values()])
        livetimes.append(livetime)

fig = plot_volumes.plot_multivolumes_vs_stat(pcubes, min_stat, max_stat,
    stat_label, colors, labels, livetimes=livetimes, logx=opts.logx, logy=True,
    nbins=opts.npoints, threshold=None, xmin=min_stat, xmax=max_stat,
    ymin=opts.y_min, ymax=opts.y_max)

# save and exit
fig.savefig(opts.output, dpi=opts.dpi, bbox_inches='tight')

print "done"

sys.exit(0)
